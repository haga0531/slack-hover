import type { App, SlashCommand } from "@slack/bolt";
import { ThreadService } from "../../services/slack/thread.service.js";
import { GeminiService } from "../../services/llm/gemini.service.js";
import { logger } from "../../middleware/logger.js";
import type { SupportedLanguage } from "../../types/summary.js";

export function registerSummarizeCommand(app: App) {
  app.command("/summarize", async ({ command, ack, client, respond }) => {
    await ack();

    const { channel_id, user_id, text } = command;

    logger.info(
      { channelId: channel_id, userId: user_id },
      "Summarize command received"
    );

    try {
      // Parse target language from command text (e.g., "/summarize ja" or "/summarize en")
      const targetLanguage = parseTargetLanguage(text);

      // Get thread_ts from the command context
      // Note: Slash commands don't have thread_ts directly, user needs to run in thread
      const threadTs = extractThreadTs(command);

      if (!threadTs) {
        await respond({
          response_type: "ephemeral",
          text: "Please run this command in a thread, or provide a message link.\nUsage: `/summarize [language]` (e.g., `/summarize ja`)",
        });
        return;
      }

      // Show loading message
      await respond({
        response_type: "ephemeral",
        text: "Summarizing thread... Please wait.",
      });

      // Fetch thread messages
      const threadService = new ThreadService(client);
      const messages = await threadService.fetchThreadMessages(
        channel_id,
        threadTs
      );

      if (messages.length === 0) {
        await respond({
          response_type: "ephemeral",
          text: "No messages found in this thread.",
        });
        return;
      }

      // Generate summary
      const geminiService = new GeminiService();
      const summary = await geminiService.summarizeThread(
        messages,
        targetLanguage
      );

      // Format and send response
      const formattedSummary = formatSummaryForSlack(summary);

      await respond({
        response_type: "ephemeral",
        blocks: formattedSummary,
      });
    } catch (error) {
      logger.error({ error }, "Error processing summarize command");

      await respond({
        response_type: "ephemeral",
        text: "Sorry, an error occurred while generating the summary. Please try again later.",
      });
    }
  });
}

function parseTargetLanguage(text: string): SupportedLanguage {
  const langMap: Record<string, SupportedLanguage> = {
    ja: "ja",
    japanese: "ja",
    en: "en",
    english: "en",
    zh: "zh",
    chinese: "zh",
    ko: "ko",
    korean: "ko",
    es: "es",
    spanish: "es",
    fr: "fr",
    french: "fr",
    de: "de",
    german: "de",
  };

  const input = text.trim().toLowerCase();
  return langMap[input] || "ja"; // Default to Japanese
}

function extractThreadTs(command: SlashCommand): string | null {
  // In Slack, when a slash command is run in a thread,
  // the thread_ts is not directly available in the command payload.
  // Users need to provide a message link or use message shortcuts instead.
  // For MVP, we'll return null and guide users to use message shortcuts.
  return null;
}

function formatSummaryForSlack(summary: {
  title: string;
  overview: string;
  decisions: string[];
  todos: Array<{ text: string; assignee?: string }>;
  blockers: string[];
  techNotes: string[];
}) {
  const blocks: Array<{
    type: string;
    text?: { type: string; text: string };
    elements?: Array<{ type: string; text: string }>;
  }> = [
    {
      type: "header",
      text: {
        type: "plain_text",
        text: summary.title,
      },
    },
    {
      type: "section",
      text: {
        type: "mrkdwn",
        text: `*Overview*\n${summary.overview}`,
      },
    },
  ];

  if (summary.decisions.length > 0) {
    blocks.push({
      type: "section",
      text: {
        type: "mrkdwn",
        text: `*Decisions*\n${summary.decisions.map((d) => `• ${d}`).join("\n")}`,
      },
    });
  }

  if (summary.todos.length > 0) {
    const todoText = summary.todos
      .map((t) => `• ${t.text}${t.assignee ? ` (<@${t.assignee}>)` : ""}`)
      .join("\n");
    blocks.push({
      type: "section",
      text: {
        type: "mrkdwn",
        text: `*TODOs*\n${todoText}`,
      },
    });
  }

  if (summary.blockers.length > 0) {
    blocks.push({
      type: "section",
      text: {
        type: "mrkdwn",
        text: `*Blockers*\n${summary.blockers.map((b) => `• ${b}`).join("\n")}`,
      },
    });
  }

  if (summary.techNotes.length > 0) {
    blocks.push({
      type: "section",
      text: {
        type: "mrkdwn",
        text: `*Technical Notes*\n${summary.techNotes.map((n) => `• ${n}`).join("\n")}`,
      },
    });
  }

  blocks.push({
    type: "context",
    elements: [
      {
        type: "mrkdwn",
        text: "_Generated by Slack Thread Summarizer_",
      },
    ],
  });

  return blocks;
}
